¬°Perfecto! Est√°s muy cerca. S√≠, ahora vamos a **refactorizar este componente `ModalForm`** para que use el componente gen√©rico `UserForm.tsx` (que ya renombraremos a `DynamicForm.tsx` o algo m√°s neutro si quieres).

La idea es que no tengas un `UserForm` ni `RoleForm` separados, sino un solo componente que reciba v√≠a props un array de campos (inputs) a renderizar.

### ‚úÖ Refactor paso a paso

#### 1. Cambiar el nombre del componente `UserForm.tsx` a algo como `DynamicForm.tsx`

Ese ser√° nuestro formulario reutilizable.

#### 2. Refactorizar `ModalForm.tsx` para usar ese componente √∫nico.

Aqu√≠ te muestro c√≥mo quedar√≠a el nuevo `ModalForm.tsx` **usando `DynamicForm.tsx`** y una definici√≥n de formularios seg√∫n el tipo (`users` o `roles`):

---

### üìÑ `ModalForm.tsx`

```tsx
import CloseIcon from "@mui/icons-material/Close";
import "../../../assets/styles/modalnewuser.css";

// Importa tu nuevo formulario din√°mico
import DynamicForm from "./DynamicForm";

interface ModalFormProps {
  open: boolean;
  onClose: () => void;
  typeFormInModal: "users" | "roles";
}

const formConfig = {
  users: {
    title: "Nuevo Usuario",
    fields: [
      { label: "Nombre", name: "name", type: "text" },
      { label: "Correo", name: "email", type: "email" },
      { label: "Contrase√±a", name: "password", type: "password" },
      { label: "Rol", name: "role", type: "select", options: ["Admin", "Doctor", "Contador"] },
    ],
  },
  roles: {
    title: "Nuevo Rol",
    fields: [
      { label: "Nombre del rol", name: "roleName", type: "text" },
      { label: "Descripci√≥n", name: "description", type: "textarea" },
    ],
  },
};

export default function ModalForm({ open, onClose, typeFormInModal }: ModalFormProps) {
  if (!open) return null;

  const config = formConfig[typeFormInModal];

  return (
    <div className="modal-overlay" onClick={onClose}>
      <div className="modal-content" onClick={(e) => e.stopPropagation()}>
        <button className="modal-close" onClick={onClose}>
          <CloseIcon />
        </button>
        <h2>{config.title}</h2>
        <DynamicForm fields={config.fields} onClose={onClose} />
      </div>
    </div>
  );
}
```

---

### üìÑ `DynamicForm.tsx`

Este ser√° tu componente gen√©rico, que renderiza cualquier formulario seg√∫n los campos recibidos.

```tsx
import { useState } from "react";

interface FieldConfig {
  label: string;
  name: string;
  type: "text" | "email" | "password" | "select" | "textarea";
  options?: string[]; // solo para selects
}

interface DynamicFormProps {
  fields: FieldConfig[];
  onClose: () => void;
}

export default function DynamicForm({ fields, onClose }: DynamicFormProps) {
  const [formData, setFormData] = useState<Record<string, string>>({});

  const handleChange = (e: React.ChangeEvent<HTMLInputElement | HTMLSelectElement | HTMLTextAreaElement>) => {
    const { name, value } = e.target;
    setFormData(prev => ({ ...prev, [name]: value }));
  };

  const handleSubmit = (e: React.FormEvent) => {
    e.preventDefault();
    console.log("Formulario enviado:", formData);
    onClose();
  };

  return (
    <form onSubmit={handleSubmit} className="form-container">
      {fields.map(field => (
        <div key={field.name} className="form-group">
          <label htmlFor={field.name}>{field.label}</label>
          {field.type === "select" ? (
            <select name={field.name} value={formData[field.name] || ""} onChange={handleChange}>
              <option value="">Seleccione una opci√≥n</option>
              {field.options?.map(option => (
                <option key={option} value={option}>{option}</option>
              ))}
            </select>
          ) : field.type === "textarea" ? (
            <textarea name={field.name} value={formData[field.name] || ""} onChange={handleChange} />
          ) : (
            <input type={field.type} name={field.name} value={formData[field.name] || ""} onChange={handleChange} />
          )}
        </div>
      ))}
      <div className="form-actions">
        <button type="submit">Guardar</button>
      </div>
    </form>
  );
}
```

---

### üß© Ventajas del refactor

- Un solo componente (`DynamicForm`) para m√∫ltiples formularios.
- Configurable con solo cambiar los campos desde `ModalForm.tsx`.
- Escalable para m√°s formularios como "nuevo paciente", "nueva cita", etc.

---

¬øTe gustar√≠a que tambi√©n te ayude con los estilos y validaciones, o que los campos puedan recibir valores iniciales para edici√≥n en el futuro?